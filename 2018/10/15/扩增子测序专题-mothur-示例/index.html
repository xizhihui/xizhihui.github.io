<!DOCTYPE html>
<html>
<head>
	<title>XZH's Notes</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="author" content="xizhihui" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<link rel="stylesheet" type="text/css" href="/statics/reset.css">
	<link rel="stylesheet" type="text/css" href="/statics/header_footer.css"></link>
	<link rel="stylesheet" type="text/css" href="/statics/default.css">
	<link rel="stylesheet" type="text/css" href="/statics/main.css">
</head>
<body>
	<header class="Header">
		<nav>
			<h3>XZH</h3>
			<ul>
				<li><a href="/index.html#Timeline">Timeline</a></li><li><a href="/index.html#Category">Category</a></li><li><a href="/index.html#Tags">Tags</a></li><li><a href="/index.html#About">About</a></li>
			</ul>
		</nav>
	</header>
	<div class="Motto">
		<h2>XZH's Notes</h2>
		<h4>The future comes for you ~ ~ ~</h4>
	</div>

	<main>
		<nav id="table"></nav>
		<content id="content" class="content">
			<h2 id="mothur">使用mothur进行扩增子分析</h2>
<h3 id="1">1. 初始说明</h3>
<ul>
<li>测序数据类型</li>
</ul>
<p>Illumina Miseq paired-end reads</p>
<ul>
<li>实验设计</li>
</ul>
<p>断奶后365天(dpw 365)的小鼠排泄物，比较初始10天(dpw 10)和中间10天(dpw140-150)的排泄物的微生物组的稳定性(肠道微生物组的变化情况)。为了简化操作，只用到一只小鼠的十个时间点(前5后5)的数据。这里还有模拟了由21种细菌组成的菌群的全基因组测序数据。先用小鼠的排泄物测序数据学习分析微生物群落，然后用模拟的菌落判断分析的错误率和它在其他分析中的作用。</p>
<ul>
<li>关于软件</li>
</ul>
<p>mothur既提供交互模式(像python)，也提供命令行模式；后者可以进行批量操作。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 解析模式一</span>
mothur <span class="c1"># 进入解析模式</span>
make.files<span class="o">(</span>....<span class="o">)</span>
quit<span class="o">()</span> <span class="c1"># 退出解析模式</span>

<span class="c1"># 命令行模式</span>
mothur <span class="s1">&#39;#make.config(file=stability.files, processors=8)&#39;</span>
<span class="c1"># 批量操作,把多个命令写入cmd.batch文件里</span>
mothur cmd.batch
</pre></div>


<h3 id="2-mothur">2 进入mothur交互模式</h3>
<div class="codehilite"><pre><span></span>mothur
set.dir<span class="o">(</span><span class="nv">tempdefault</span><span class="o">=</span>MiSeq_SOP<span class="o">)</span>
set.dir<span class="o">(</span><span class="nv">inputdir</span><span class="o">=</span>MiSeq_SOP<span class="o">)</span>
help<span class="o">(</span>query_cmd<span class="o">)</span>
</pre></div>


<h3 id="3-stabilityfiles">3 stability.files</h3>
<p>这个文件记录了每个样品对应的read1和read2文件。</p>
<div class="codehilite"><pre><span></span>make.file<span class="o">(</span><span class="nv">inputdir</span><span class="o">=</span>MiSeq_SOP, <span class="nv">type</span><span class="o">=</span>fastq, <span class="nv">prefix</span><span class="o">=</span>metadata<span class="o">)</span>
</pre></div>


<h3 id="4-pcr">4 序列合并和质控：减少测序和PCR错误</h3>
<p>使用make.configs合并序列,合并逻辑是先对两个reads比对，找到overlap；根据overla的base quality score，如果是base-gap，那么base的质量值要大于25才取base否则认为该位置没有base；如果是base-base，base的质量值要大于6才取base；否则置为N。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 1. 合并序列</span>
make.contigs<span class="o">(</span><span class="nv">file</span><span class="o">=</span>metadata.files, <span class="nv">processor</span><span class="o">=</span><span class="m">8</span><span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.[fasta,qual]</span>
        <span class="c1"># MiSeq_SOP/metadata.scrap.contigs.[fasta, qual]</span>
        <span class="c1"># MiSeq_SOP/metadata.contigs.[report, groups]</span>
<span class="c1"># 2. 统计合并后的序列</span>
summary.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.fasta<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.summary</span>

<span class="c1"># 3. 筛选合并后的序列, 排除含有N和长度大于275的序列</span>
screen.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.fasta, 
        <span class="nv">summary</span><span class="o">=</span>metadata.trim.contigs.summary, 
        <span class="nv">group</span><span class="o">=</span>metadata.contigs.groups, 
        <span class="nv">maxambig</span><span class="o">=</span><span class="m">0</span>, <span class="nv">maxlength</span><span class="o">=</span><span class="m">275</span><span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.contigs.[pick, good].groups</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.[good.summary, good.fasta, bad.accnos]</span>
</pre></div>


<h3 id="5">5 序列的去冗余</h3>
<div class="codehilite"><pre><span></span><span class="c1"># 1.去测序冗余</span>
unique.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.fasta<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.[names, unique.fasta]</span>
<span class="c1"># 2.生成count矩阵</span>
count.seqs<span class="o">(</span><span class="nv">name</span><span class="o">=</span>metadata.trim.contigs.good.names, 
        <span class="nv">group</span><span class="o">=</span>metadata.contigs.good.groups<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.count_table</span>

<span class="c1"># 3.对count矩阵进行统计</span>
summary.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.fasta, 
        <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.count_table<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.summary</span>

<span class="c1"># 4.去非扩增区域冗余; 通过设置参考数据库中你的PCR扩增区域来去除非扩增区域的序列，以减少比对量</span>
<span class="c1">#   你可以使用oligos来指定primer文件进行去除，keepprimer</span>
pcr.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>../silva.bacteria/silva.bacteria.fasta, <span class="nv">start</span><span class="o">=</span><span class="m">11894</span>, <span class="nv">end</span><span class="o">=</span><span class="m">25319</span>, <span class="nv">keepdots</span><span class="o">=</span>F, <span class="nv">processors</span><span class="o">=</span><span class="m">8</span><span class="o">)</span>
        <span class="c1"># silva.bacteria/silva.bacteria.pcr.fasta</span>
rename.file<span class="o">(</span><span class="nv">input</span><span class="o">=</span>../silva.bacteria/silva.bacteria.pcr.fasta, <span class="nv">new</span><span class="o">=</span>silva.v4.fasta<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/silva.v4.fasta</span>

<span class="c1"># 5. 对silva.v4.fasta进行统计</span>
summar.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>silva.v4.fasta<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/silva.v4.summary</span>
</pre></div>


<h3 id="6">6 序列的预聚类</h3>
<p>要进行预聚类，我们需要先进行序列比对，获得相似序列。</p>
<h4 id="61">6.1 序列比对</h4>
<div class="codehilite"><pre><span></span><span class="c1"># 1.比对并统计</span>
align.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.fasta, <span class="nv">reference</span><span class="o">=</span>silva.v4.fasta<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.align.[&#39;&#39;, report]</span>
summary.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.align,
        <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.count_table<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.summary</span>

<span class="c1"># 2. 根据比对统计结果，大部分序列比对在1968-11550, polymer最大为8；再进行一次筛选序列</span>
screen.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.align, <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.count_table, <span class="nv">summary</span><span class="o">=</span>metadata.trim.contigs.good.unique.summary, <span class="nv">start</span><span class="o">=</span><span class="m">1968</span>, <span class="nv">end</span><span class="o">=</span><span class="m">11550</span>, <span class="nv">maxhomop</span><span class="o">=</span><span class="m">8</span><span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.summary</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.align</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.accnos</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.good.count_table</span>
summary.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>current, <span class="nv">count</span><span class="o">=</span>current<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.summary</span>

<span class="c1"># 3. 把比对结果中未必对上部分序列和表示gap的-去掉</span>
filter.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.align, <span class="nv">vertical</span><span class="o">=</span>T, <span class="nv">trump</span><span class="o">=</span>.<span class="o">)</span>
        <span class="c1"># Length of filtered alignment: 376 </span>
        <span class="c1"># Number of columns removed: 13049</span>
        <span class="c1"># Length of the original alignment: 13425</span>
        <span class="c1"># Number of sequences used to construct filter: 16299</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.fasta</span>
        <span class="c1"># MiSeq_SOP/metadata.filter</span>

<span class="c1"># 4. 去冗余, 在上一步剪切序列时可能产生</span>
unique.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.fasta, <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.good.count_table<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.count_table</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.fasta</span>
</pre></div>


<h4 id="62">6.2 预聚类</h4>
<p>这里使用pre.cluster进行预聚类。它首先根据group对序列分组，然后依据序列丰度进行排序，最后把差异在2个核苷酸及以内的序列进行合并。一般是100bp取1个核苷酸的差异,这里的序列长度是250左右，所以为2。</p>
<div class="codehilite"><pre><span></span>pre.cluster<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.fasta, <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.count_table, <span class="nv">diffs</span><span class="o">=</span><span class="m">2</span><span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.precluster.[SampleID].map</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.precluster.[fasta,count_table]</span>
</pre></div>


<h3 id="7-chimeras">7 去除嵌合体 chimeras</h3>
<p>chimera.vsearch将会把数据按样品分组，检测嵌合体的存在。我们倾向于使用高丰度序列作为reference。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 1. 检测嵌合体序列；输出的count_table依据去除了</span>
chimera.vsearch<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.fasta,
        <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.count_table, 
        <span class="nv">dereplicate</span><span class="o">=</span>T<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.[pick.count_table, chimeras,accnos]</span>
<span class="c1"># 2. 去除嵌合体序列</span>
remove.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.fasta,
        <span class="nv">accnos</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.accnos<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.fasta</span>
<span class="c1"># 3. 统计</span>
summary.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>current, <span class="nv">count</span><span class="o">=</span>current<span class="o">)</span>
    <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.summary</span>
</pre></div>


<h3 id="8">8 进行聚类（分类）</h3>
<div class="codehilite"><pre><span></span><span class="c1"># 1. 分类</span>
classify.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.fasta,
        <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.count_table,
        <span class="nv">reference</span><span class="o">=</span>../trainset9_032012.pds.fasta, 
        <span class="nv">taxonomy</span><span class="o">=</span>trainset9_032012.pds.tax, <span class="nv">cutoff</span><span class="o">=</span><span class="m">80</span><span class="o">)</span>
    <span class="c1"># MiSeq_SOP/metadata.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.[taxonomy, tax.summary]</span>

<span class="c1"># 2. 去除污染; 这里的unknown是在上一步分类时无法根据训练集和准确进行准确分类的一类</span>
remove.lineage<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>current, <span class="nv">count</span><span class="o">=</span>current, <span class="nv">taxonomy</span><span class="o">=</span>current, <span class="nv">taxon</span><span class="o">=</span>Chloroplast-Mitochondria-unknown-Archaea-Eukaryota<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.taxonomy</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.fasta</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.count_table</span>

<span class="c1"># 3. 统计</span>
summary.tax<span class="o">(</span><span class="nv">taxonomy</span><span class="o">=</span>current, <span class="nv">count</span><span class="o">=</span>current<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.tax.summary</span>
</pre></div>


<h3 id="9">9 检测错误率</h3>
<p>如果你在测序的时候有一些模拟群落的数据的话，你就可以检测一下你的数据的错误率。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 1. 提取出mock的分组</span>
get.groups<span class="o">(</span><span class="nv">count</span><span class="o">=</span>current, <span class="nv">fasta</span><span class="o">=</span>current, <span class="nv">groups</span><span class="o">=</span>Mock<span class="o">)</span>
        <span class="c1"># MiSeq_SOP/metadata.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table</span>
        <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.fasta</span>

<span class="c1"># 2. 检测错误率</span>
seq.error<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>current, <span class="nv">count</span><span class="o">=</span>current, <span class="nv">reference</span><span class="o">=</span>HMP_MOCK.v35.fasta, <span class="nv">aligned</span><span class="o">=</span>F<span class="o">)</span>
        <span class="c1"># Overall error rate:   6.5108e-05</span>
    <span class="c1"># MiSeq_SOP/metadata.trim.contigs.good.unique.good.filter.unique.</span>
    <span class="c1"># precluster.pick.pick.pick.error.[summary,seq,chimera,seq.forward, seq.reverse, count, matrix, ref]</span>
</pre></div>


<h3 id="10-mock-otus">10 生成Mock OTUs</h3>
<div class="codehilite"><pre><span></span><span class="c1"># 1. 计算距离</span>
dist.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.fasta,
    <span class="nv">cutoff</span><span class="o">=</span><span class="m">0</span>.03<span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.dist</span>

<span class="c1"># 2.进行聚类</span>
cluster<span class="o">(</span><span class="nv">column</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.dist,
    <span class="nv">count</span><span class="o">=</span>metadata.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table<span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.[list, steps, sensspec]</span>

<span class="c1"># 3. 生成shared文件</span>
make.shared<span class="o">(</span><span class="nv">list</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.list,
    <span class="nv">count</span><span class="o">=</span>metadata.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table, 
    <span class="nv">label</span><span class="o">=</span><span class="m">0</span>.03<span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.shared</span>

<span class="c1"># 4. 稀释</span>
rarefaction.single<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.shared<span class="o">)</span>
        <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.groups.rarefaction</span>
</pre></div>


<h3 id="11">11 准备分析</h3>
<p>接下来我们有2件事要做。第一件就是把序列与OTU对应起来，第二件是把序列和系统发育表型对应起来。
当前我们需要把mock数据从我们的数据集里面去掉。</p>
<div class="codehilite"><pre><span></span>remove.groups<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.fasta,
    <span class="nv">count</span><span class="o">=</span>metadata.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.count_table,
    <span class="nv">taxonomy</span><span class="o">=</span>metadata.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.taxonomy, 
    <span class="nv">groups</span><span class="o">=</span>Mock<span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.fasta</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.pick.taxonomy</span>
</pre></div>


<h3 id="12-otus">12 生成OTUs</h3>
<p>对于较小的数据集，可以使用dist.seqs和cluster来进行，就像前面Mock OTUs一样。 对于大的数据集，使用cluster.split。在该方法中，会先根据分类信息对序列进行分箱，然后在各个箱内进行聚类。对于指定的分类水平，可以通过指定taxlevel=level来实现。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 1. 生成OTUs</span>
<span class="c1"># dist.seqs + cluster</span>
dist.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>curent, <span class="nv">count</span><span class="o">=</span>current<span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.dist</span>

cluster<span class="o">(</span><span class="nv">column</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.dist, <span class="nv">count</span><span class="o">=</span>current<span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.[list,steps,sensspec]</span>

<span class="c1"># cluster.split</span>
cluster.split<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.fasta,
    <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table,
    <span class="nv">taxonomy</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.pick.taxonomy, 
    <span class="nv">splitmethod</span><span class="o">=</span>classify, <span class="nv">cutoff</span><span class="o">=</span><span class="m">0</span>.03, <span class="nv">taxlevel</span><span class="o">=</span><span class="m">4</span><span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.[list,steps,sensspec]</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="c1"># 2. 生成shared文件(每个样品为行，每个OTU为列，OTU数目矩阵)</span>
makd.shared<span class="o">(</span><span class="nv">list</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.list,
    <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table, 
    <span class="nv">label</span><span class="o">=</span><span class="m">0</span>.03<span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.shared</span>
</pre></div>


<p>然后使用classify.otu给每个OTU同对应的物种分类联系起来。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 3. otu被观察到的次数（OTU丰度）和对应的物种分类信息</span>
classify.otu<span class="o">(</span><span class="nv">list</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.list,
    <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table, 
    <span class="nv">label</span><span class="o">=</span><span class="m">0</span>.03<span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.</span>
    <span class="c1"># pick.pick.pick.opti_mcc.0.03.cons.[taxonomy, tax.summary]</span>
</pre></div>


<h3 id="13-phylotypes">13 生成phylotypes 系统发育表型信息</h3>
<p>你可以使用phylotype来对序列按照他们的物种分类分箱成系统发育表型。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 1. 生成系统发育表型表</span>
phylotype<span class="o">(</span><span class="nv">taxnomy</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.taxonomy<span class="o">)</span>   <span class="c1"># current</span>
        <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.</span>
        <span class="c1"># precluster.pick.pds.wang.pick.pick.tx.[sabund, rabund, list]</span>

<span class="c1"># 2. 生成shared文件，这里生成level6，genus的;这里设置label是从1-7对应着genus-kingdom</span>
make.shared<span class="o">(</span><span class="nv">list</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.pick.tx.list,
    <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table,
    <span class="nv">label</span><span class="o">=</span><span class="m">1</span><span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.pick.tx.shared</span>
    <span class="c1"># label   Group   numOtus Otu01   Otu02   Otu03   Otu04</span>
    <span class="c1"># 1       F3D0    62      1663    2626    216     57</span>
    <span class="c1"># 1       F3D1    62      1959    1249    246     35</span>

<span class="c1"># 3. 生成OTU丰度、对应的物种分类信息</span>
classify.otu<span class="o">(</span><span class="nv">list</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.pick.tx.list,
    <span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table, 
    <span class="nv">label</span><span class="o">=</span><span class="m">1</span><span class="o">)</span>
    <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.</span>
    <span class="c1"># precluster.pick.pds.wang.pick.pick.tx.1.cons.[taxonomy,tax.summary]</span>
    <span class="c1"># OTU     Size    Taxonomy</span>
    <span class="c1"># Otu01   22183   Bacteria(100);...;Lachnospiraceae_unclassified(100);</span>
    <span class="c1"># Otu02   54221   Bacteria(100);...;&quot;Porphyromonadaceae&quot;_unclassified(100);</span>
</pre></div>


<h3 id="14">14 生成系统发育树</h3>
<p>我们可以使用clearcut来生成系统发育树，它既可以以比对后的序列作为输入，也可以以序列距离来作为输入。这里以序列距离作为输入。如果以比对后的序列作为输入，你需要指定序列是DNA还是蛋白。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 1. 计算距离; fasta和计算OTUs的是一致的</span>
dist.seqs<span class="o">(</span><span class="nv">fasta</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.fasta, 
        <span class="nv">output</span><span class="o">=</span>lt, <span class="nv">processors</span><span class="o">=</span><span class="m">8</span><span class="o">)</span>
        <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.phylip.dist</span>

<span class="c1"># 2. 生成树</span>
clearcut<span class="o">(</span><span class="nv">phylip</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.phylip.dist<span class="o">)</span> <span class="c1"># current</span>
        <span class="c1"># metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.phylip.tre</span>
</pre></div>


<h3 id="15-otu-based">15 准备分析: OTU-based</h3>
<p>下面我们要进行基于OTU的分析，基于phylotype的分析也是一样的操作. 为了简化，我们要把current的各个相关的默认参数指定为OTU的。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 这里这样设置后，...0.03.cons.taxonomy就成了metadata.taxonomy</span>
rename.files<span class="o">(</span><span class="nv">taxonomy</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.0.03.cons.taxonomy,
    <span class="nv">shared</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.shared<span class="o">)</span>
</pre></div>


<p>如果要知道每个样品有多少条序列，可以这么做. 然后对样品进行稀释抽样</p>
<div class="codehilite"><pre><span></span><span class="c1"># 1. 对序列进行分组计数；得到样品的最小总序列数是2390</span>
count.groups<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.shared<span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.count.summary</span>

<span class="c1"># 2. 进行稀释抽样，抽样大小是2390</span>
sub.sample<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.shared, <span class="nv">size</span><span class="o">=</span><span class="m">2390</span><span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.shared</span>
</pre></div>


<h3 id="16-otu-alpha-diversity">16 基于OTU的分析: alpha diversity</h3>
<ul>
<li>稀释曲线</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1"># 生成的稀释表，需要你自己去画图</span>
<span class="c1"># calc指定计算哪个alpha diversity index, 有多个的话，sobs-chao-ace</span>
<span class="c1">#  ace, bootstrap, chao, coverage, default, heip, invsimpson, jack, npshannon, nseqs, shannon, shannoneven, shannonrange, simpson, simpsoneven, smithwilson, sobs</span>
rarefection.single<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.shared, <span class="nv">calc</span><span class="o">=</span>sobs, <span class="nv">freq</span><span class="o">=</span><span class="m">100</span><span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.groups.rarefaction</span>
</pre></div>


<ul>
<li>生成一个含序列数目、sample converage, observed OTUs, inverse simpson diversity estimation的表</li>
</ul>
<p>基于这里的ave-std.summary，你还可以进行repeated-measures ANOVA进行分组的组间差异比较</p>
<div class="codehilite"><pre><span></span>summary.single<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.shared, <span class="nv">calc</span><span class="o">=</span>nseqs-coverage-sobs-invsimpson, <span class="nv">subsample</span><span class="o">=</span><span class="m">2390</span><span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.groups.ave-std.summary</span>
        <span class="c1"># metadata.opti_mcc.groups.summary</span>
</pre></div>


<h3 id="17-otu-beta-diversity">17 基于OTU的分析: beta diversity</h3>
<p>现在我们要比较样品的关系和组成了。</p>
<ul>
<li>OTU 相对丰度热图</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1"># 你可以直接使用metadata.opti_mcc.0.03.subsample.shared在R里面画热图</span>
heatmap.bin<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.0.03.subsample.shared, <span class="nv">scale</span><span class="o">=</span>log2, <span class="nv">numotu</span><span class="o">=</span><span class="m">50</span><span class="o">)</span>
    <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.heatmap.bin.svg</span>
</pre></div>


<ul>
<li>计算样品的关系和组成相似性</li>
</ul>
<div class="codehilite"><pre><span></span>dist.shared<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.shared, <span class="nv">calc</span><span class="o">=</span>thetayc-jclass, <span class="nv">subsample</span><span class="o">=</span><span class="m">2390</span><span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.thetayc.0.03.lt.[dist, ave.dist,std.dist]</span>
        <span class="c1"># metadata.opti_mcc.jclass.0.03.lt.[dist, ave.dist,std.dist]</span>

heatmap.sim<span class="o">(</span><span class="nv">calc</span><span class="o">=</span>jcalss-thetayc<span class="o">)</span>
<span class="c1">#heatmap.sim(phylip=metadata.opti_mcc.jclass.0.03.lt.ave.dist)</span>
        <span class="c1"># metadata.opti_mcc.thetayc.0.03.lt.ave.heatmap.sim.svg</span>
        <span class="c1"># metadata.opti_mcc.jclass.0.03.lt.ave.heatmap.sim.svg</span>
</pre></div>


<ul>
<li>venn图</li>
</ul>
<p>当组别在5以内时，利用veen才方便。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 利用生成的.sharedotus到R里面画图</span>
venn<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.0.03.subsample.shared, <span class="nv">groups</span><span class="o">=</span>F3D0-F3D1-F3D2-F3D3<span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.sharedsobs.F3D0-F3D1-F3D2-F3D3.svg</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.sharedsobs.F3D0-F3D1-F3D2-F3D3.sharedotus</span>
</pre></div>


<ul>
<li>系统发育树</li>
</ul>
<p>这里利用tree.shared来画系统发育树，以可视化样品之间的相似性。</p>
<div class="codehilite"><pre><span></span><span class="c1"># 这里选择jclass</span>
tree.shared<span class="o">(</span><span class="nv">phylip</span><span class="o">=</span>metadata.opti_mcc.jclass.0.03.lt.ave.dist<span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.jclass.0.03.lt.ave.tre</span>
</pre></div>


<ul>
<li>基于系统发育树的差异比较</li>
</ul>
<p>parsimony, unifrac.unweighted, unifrac.weighted.
我们需要构建一个design文件，以指示那个样品属于哪个组；然后进行计算</p>
<div class="codehilite"><pre><span></span>parsimony<span class="o">(</span><span class="nv">tree</span><span class="o">=</span>metadata.opti_mcc.jclass.0.03.lt.ave.tre, <span class="nv">group</span><span class="o">=</span>mouse.time.desin, <span class="nv">groups</span><span class="o">=</span>all<span class="o">)</span>
        <span class="c1"># Tree#   Groups  ParsScore       ParsSig</span>
        <span class="c1"># 1       Early-Late      1       &lt;0.001</span>
        <span class="c1"># metadata.opti_mcc.jclass.0.03.lt.ave.tre.parsimony</span>
        <span class="c1"># metadata.opti_mcc.jclass.0.03.lt.ave.tre.psummary</span>
</pre></div>


<ul>
<li>PCoA和nmds分析/可视化</li>
</ul>
<div class="codehilite"><pre><span></span>pcoa<span class="o">(</span><span class="nv">phylip</span><span class="o">=</span>metadata.opti_mcc.jclass.0.03.lt.ave.dist<span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.jclass.0.03.lt.ave.pcoa.[axes, loadings]</span>
        <span class="c1"># metadata.opti_mcc.jclass.0.03.lt.ave.pcoa.loadings</span>

nmds<span class="o">(</span><span class="nv">phylip</span><span class="o">=</span>metadata.opti_mcc.jclass.0.03.lt.ave.dist<span class="o">)</span>
        <span class="c1"># Number of dimensions:   2</span>
        <span class="c1"># Lowest stress : 0.142764</span>
        <span class="c1"># R-squared for configuration:    0.918996</span>
        <span class="c1"># metadata.opti_mcc.thetayc.0.03.lt.ave.nmds.[iters, stress, axes]</span>
</pre></div>


<ul>
<li>AMOVA分析/HOMOVA分析</li>
</ul>
<div class="codehilite"><pre><span></span>amova<span class="o">(</span><span class="nv">phylp</span><span class="o">=</span>metadata.opti_mcc.thetayc.0.03.lt.ave.dist, <span class="nv">design</span><span class="o">=</span>mouse.time.design<span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.thetayc.0.03.lt.ave.amova</span>

homova<span class="o">(</span><span class="nv">phylip</span><span class="o">=</span>metadata.opti_mcc.thetayc.0.03.lt.ave.dist, <span class="nv">design</span><span class="o">=</span>mouse.time.desin<span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.thetayc.0.03.lt.ave.homova</span>
</pre></div>


<ul>
<li>核心OTU分析：导致差异的OTU</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1"># 生成的corr.axes文件可用biplot图可视化</span>
corr.axes<span class="o">(</span><span class="nv">axes</span><span class="o">=</span>metadata.opti_mcc.jclass.0.03.lt.ave.pcoa.axes, 
        <span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.0.03.subsample.shared, 
        <span class="nv">method</span><span class="o">=</span>spearman, <span class="nv">numaxes</span><span class="o">=</span><span class="m">3</span><span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.spearman.corr.axes</span>

corr.axes<span class="o">(</span><span class="nv">axes</span><span class="o">=</span>metadata.opti_mcc.jclass.0.03.lt.ave.pcoa.axes, 
        <span class="nv">metadata</span><span class="o">=</span>mouse.dpw.metadata, 
        <span class="nv">method</span><span class="o">=</span>spearman, <span class="nv">numaxes</span><span class="o">=</span><span class="m">3</span><span class="o">)</span>
        <span class="c1"># mouse.dpw.spearman.corr.axes</span>
</pre></div>


<ul>
<li>是否可以将数据分成不同的群落类型？</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1"># 得到的表Laplace最小值对应k=2。所以可以分为2个类型</span>
get.communitytype<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.0.03.subsample.shared<span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.dmm.mix.fit</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.dmm.[1-5].mix.posterior</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.dmm.[1-5].mix.relabund</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.dmm.mix.design，指明各个样品所属类型</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.dmm.mix.parameters</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.dmm.mix.summary，指明主要是哪个OTU导致的分类型</span>
</pre></div>


<h3 id="18">18 群体水平的分析</h3>
<ul>
<li>metastats</li>
</ul>
<div class="codehilite"><pre><span></span>metastats<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.0.03.subsample.shared, 
        <span class="nv">design</span><span class="o">=</span>mouse.time.design<span class="o">)</span>
        <span class="c1"># metadata.opti_mcc.0.03.subsample.0.03.Late_Early.metastats</span>
</pre></div>


<ul>
<li>lefse</li>
</ul>
<div class="codehilite"><pre><span></span>lefse<span class="o">(</span><span class="nv">shared</span><span class="o">=</span>metadata.opti_mcc.0.03.subsample.shared, <span class="nv">design</span><span class="o">=</span>mouse.time.design<span class="o">)</span>
</pre></div>


<h3 id="19-phylogeny-based-analysis">19 基于系统发育的分析 phylogeny-based analysis</h3>
<h4 id="191-alpha-diversity">19.1 alpha diversity</h4>
<div class="codehilite"><pre><span></span>rename.file<span class="o">(</span><span class="nv">tree</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.phylip.tre<span class="o">)</span>
rename.file<span class="o">(</span><span class="nv">count</span><span class="o">=</span>metadata.trim.contigs.good.unique.good.filter.unique.precluster.denovo.vsearch.pick.pick.pick.count_table<span class="o">)</span>
phylo.diversity<span class="o">(</span><span class="nv">tree</span><span class="o">=</span>metadata.tre, <span class="nv">count</span><span class="o">=</span>metadata.count_table, <span class="nv">rarefy</span><span class="o">=</span>T<span class="o">)</span>
        <span class="c1"># metadata.1.phylodiv.summary</span>
        <span class="c1"># phylodiv.rarefaction</span>
</pre></div>


<h4 id="192-beta-diversity">19.2 beta diversity</h4>
<div class="codehilite"><pre><span></span><span class="c1"># 生成.ave.dist是距离矩阵，可以像OTU-based analysis那样进行分析那些PCOA之类的。</span>
unifrac.unweighted<span class="o">(</span><span class="nv">tree</span><span class="o">=</span>metadata.tre, <span class="nv">count</span><span class="o">=</span>metadata.count_table, <span class="nv">distance</span><span class="o">=</span>lt, <span class="nv">processors</span><span class="o">=</span><span class="m">2</span>, <span class="nv">random</span><span class="o">=</span>F, <span class="nv">subsample</span><span class="o">=</span><span class="m">2390</span><span class="o">)</span>
unifrac.weighted<span class="o">(</span><span class="nv">tree</span><span class="o">=</span>metadata.tre, <span class="nv">count</span><span class="o">=</span>metadata.count_table, <span class="nv">distance</span><span class="o">=</span>lt, <span class="nv">processors</span><span class="o">=</span><span class="m">2</span>, <span class="nv">random</span><span class="o">=</span>F, <span class="nv">subsample</span><span class="o">=</span><span class="m">2390</span><span class="o">)</span>
        <span class="c1"># metadata.uwsummary</span>
        <span class="c1"># metadata.1.unweighted.ave.dist</span>
        <span class="c1"># metadata.1.unweighted.std.dist</span>
        <span class="c1"># metadata.tre1.unweighted.phylip.dist</span>
</pre></div>
		</content>

	</main>
	<footer>
		<p> Powered by xizhihui </p>
		<p> Thanks to <a href="https://www.hifreud.com/">hifreud</a> the theme is learned from his site. </p>
	</footer>

<script type="text/javascript" src="/js/index.json"></script>
<script type="text/javascript" src="/js/category.json"></script>
<script type="text/javascript" src="/js/tags.json"></script>
<script type="text/javascript" src="/js/about.json"></script>
<script type="text/javascript" src="/js/index.js"></script>
<script type="text/javascript">
	// listen to click event on navigator in header
	// document
	// 	.querySelector("div#head_right ul")
	// 	.addEventListener("click", change_page)
	var table = [['h2', 'mothur', '使用mothur进行扩增子分析'], ['h3', '1', '1. 初始说明'], ['h3', '2-mothur', '2 进入mothur交互模式'], ['h3', '3-stabilityfiles', '3 stability.files'], ['h3', '4-pcr', '4 序列合并和质控：减少测序和PCR错误'], ['h3', '5', '5 序列的去冗余'], ['h3', '6', '6 序列的预聚类'], ['h4', '61', '6.1 序列比对'], ['h4', '62', '6.2 预聚类'], ['h3', '7-chimeras', '7 去除嵌合体 chimeras'], ['h3', '8', '8 进行聚类（分类）'], ['h3', '9', '9 检测错误率'], ['h3', '10-mock-otus', '10 生成Mock OTUs'], ['h3', '11', '11 准备分析'], ['h3', '12-otus', '12 生成OTUs'], ['h3', '13-phylotypes', '13 生成phylotypes 系统发育表型信息'], ['h3', '14', '14 生成系统发育树'], ['h3', '15-otu-based', '15 准备分析: OTU-based'], ['h3', '16-otu-alpha-diversity', '16 基于OTU的分析: alpha diversity'], ['h3', '17-otu-beta-diversity', '17 基于OTU的分析: beta diversity'], ['h3', '18', '18 群体水平的分析'], ['h3', '19-phylogeny-based-analysis', '19 基于系统发育的分析 phylogeny-based analysis'], ['h4', '191-alpha-diversity', '19.1 alpha diversity'], ['h4', '192-beta-diversity', '19.2 beta diversity']]
	var html = format_article_table(table)
	var table_ele = document.querySelector("main #table")
	table_ele.innerHTML = html
	// window.onload = evt => resize_nav(table_ele)
	adaption(document, window)

</script>
</body>
</html>